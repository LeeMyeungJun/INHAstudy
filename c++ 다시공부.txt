내가부족한것 디폴트 매개변수를 사용
void 포인터 
참조자 와 포인터의 차이점
1. 참조자는 반드시 선언과 동시에 초기화되어야한다. 초기화시키지않으면 컴파일 오류가생김
int k =10;
int &ref; //ERROR
int &ref = k; //OK

2. 참조자는 일견 포인터와 비슷해보인다. 하지만 차이가 있다 포인터는 변수다 . 
따라서 포인터가 가리키는 대상은 변경될수있다 .
하지만 참조자에는 자신만의 메모리 공간이 할당되지않는다 
따라서 참조자가 가리키는 대상은 변경할수없음.

int &ref = k;
ref = k2; //ERROR

3.참조자를 상수로 초기화시킬수없다. 

일반적으로 포인터보다는 참조자를 사용하는편이 더깔끔하고 쉽다 . 
하지만 참조자는 참조대상을 변경할수없다 .
따라서 참조하는 대상이 수시로 변경되는경우에는 포인터 . 
참조자는 널이 될수없으므로 널이 될가능성이 있는경우에도 포인터 

포인터
> 수시로 변경되는경우 , 참조자는 널이될수없으므로 널이 될가능성이 있는경우 
그외 참조자 


참조자는 주로 함수 호출시에 매개변수와 반환값으로 사용 



#include<cstring> 설명 char s[] 문자열인데 c++에서는 잘사용은안함 하지만 알아두면좋음

strlen(s) : s문자열의 길이를구함 > 배열의 크기를구하는게아냐 문자열의 길이
strcpy(s1,s2): s1에 s2 복사 이렇게쓰지 strcpy(s1,"HELLO"); 이런식
strcat(s1,s2) : s1에 s2를 뒤에 더하기 HELLO 가 s1이면 s2 WORLD  >> HELLOWORLD
strcmp(s1,s2) :s1과 s2비교
strcnp(s1,s2,n) : s2의 최대문자 n개의 문자를 s1에 복사 
strncat n개의 문자까지 s1에넣기
strncmp  다똑같 n개의 문자까지 비교
strchr(s,c) :문자열s안에서 문자c찾기 잘모르겠고 잘쓰지도않을거같음 쓸거면 구글링
strstr(s1,s2) : 문자열 s1에서 문자열 s2찾기 


클래스
private > 상태 
public  동작 함수들


C언어 C++ 

C언어 절차지향 프로그래밍
과도한 전역변수 사용 > 전역변수 값을 잘못설정할수잇음
프로그램의 이해가어려워짐 > 수백개의 함수가있다면 보기가힘듬
확장이 어렵다. >함수를수정하다보면 다른함수에 영향이감 



C++은 그런걸 보완해줌
쉬운디버깅 절차지향프로그램에서 변수 1000개의 함수를 사용하면 
객체지향은 100개의 클래스가있고 클래스당 10개의 멤버함수가 있다고 가정하면 
클래스는 10개의 클래스를 검사하고 절차지향은 1000개를 검사해야할것이다.
데이터와 함수를 하나의덩어리로 묶는 캡슐화 클래스임

캡슐화란 데이터와 연산들을 객체안에 넣어서 묶는다는 의미
클래스 = 알고리즘 +데이터 


/*절차 지향 프로그래밍 C언어
struct Car
{
	int Speed;
	int gear;
	int *pclor;
};

void init(Car& c, char *color);
void start(Car& c);
void stop(Car& c);
int get_speed(Car &c);
void set_speed(Car& c, int speed);
*/

/*객체지향프로그래밍 C++
class Car
{
private:
	int speed;
	int gear;
	char *pcolor;
public:
	Car();
	~Car();
	void init(char *color);
	void start();
	void stop();
	int get_speed();
	void set_speed(int speed);
};
*/


string 클래스 
s.length() :길이
s.empty() : s가비어있으면 true 반환
s.inssert (pos,s2) : s의 pos위치에 s2를 삽입
s.remove(pos,len) s의 pos 위치에 len만큼을 삭제 
s.find(s2) s에서 문자열 s2가 발견되는 첫번쨰 인덱스 반환
string s1("HELLO") ,s2("WORLD");
s.erase(0,1); //0번째에서 1나만 지운다.
s.replace 글자바꿀때
s.substr 문자열 자르기
if(s1 == s2 )가능하다 String 클래스는 동일문자열 검사가능

공백이있는것도 읽으려면 getline(cin,string변수)
일반배열은 cin.getline(변수,크기) 사용했지

	if (answer.find(c) != string::npos) //찾는 
문자열이없으면 없으면 : string::npos반환한다. ,false 라생각하면될듯 0 
 있으면 : 인덱스번호로
pos = prob.find(c, pos + 1); //같은 글자가 또잇으면 반복적으로 찾음 pos인덱스+1 부터 찾는다.

접근자와 설정자를 사용하는 이유
1. 정보은닉 
2. 설정자에서 잘못된 값이 넘어오는 경우 사전에 차단할수있다 . 
 void setSpeed(int s)
{
if(s < 0)
   speed = 0;
else
  speed = s;
}
이런식

3. 멤버 변수 값을 필요할떄마다 계싼하여 반환가능
int getSpeed()
{
return (int)(rpm *2.0 * 3.14 * wheel_radius)
}

클래스는 객체의 설계도이다 . 객체가 아니다 . 


상속은 is = a관계를 따라서 상속의 계층구조를 설계했는지 생각해야한다.
ex)자동차는 탈것 이다. (Car is a Vehicle).
사자,개,고양이는 동물이다.

has = a
~은 ~을가지고있다 관계는 상속으로 모델링하면 안된다. 
ex)도서관은 책을 가지고있다 .
거실은 소파를 가지고있다.

has a 관계가 성립되는경우 
ex)직선은 양끝점을 가지고있다. 
이땐 클래스안에 점을 나타내는 객체를 포함시키자. 

has a 는 새로운클래스가 다른클래스를 가지고있을때

접근지정자	현재클래스	자식클래스	외부
private		   O		      X		 X
protected	   O		      O		 X
public		   O	    	      O		 O
308p 잘나와있음 

459p부터시작

490p stack으로 회문 짜보기 해봐 

형변환 연산자
static_cast	:기본 타입의 변환이나 클래스 포인터를 변환할때사용 
dynamic_cast	:상속 관계에있는 클래스포인터를 안전하게 변환할때 사용
const_cast	:상수 속성을 변경
reinterpret_cast	:관련없는 포인터 사이의 무조건 변환 // 위험하니까 쓰지말자 .


	//STL
	/*
	순차 컨테이너  
	자료의 추가는 빠르지만 탐색할때는 시간이 많이걸린다.
	vector : 벡터처럼 입력된 순서대로 저장  <vector> 
	list   : 순서가 있는 리스트		  <list>
	deque  : 양 끝에서 입력과 출력이 가능   <deque>

	연관 컨테이너
	원소들을 검색하기 위한 키를 가지고있다 . 자료의탐색은 매우빠르다.
	set    : 수학에서의 집합 구현          <set>
	multiset:다중 집합(중복을 허용)        <set>
	map    : 사전과 같은 구조              <map>
	multimap:다중 맵(중복을 허용)          <map>

	컨테이너 어댑터
	순차컨테이너에 제약을 가해 데이터들이 정해진방식으로만 입출력되도록한 컨테이너
	stack: 스택(후입선출)                  <stack>
	queue: 큐 (선입선출)                   <queue>
	priority_queue: 우선순위 큐(우선순위가 높은원소가 먼저 출력) <queue>

	STL이 제공하는 알고리즘 
	탐색(find) : 컨테이너 안에서 특정한 자료를 찾는다 . 
	정렬(sort) : 자료들을 크기순으로 정렬한다 . 
	반전(reverse): 자료들의 순서를 역순으로 한다 .
	삭제(remove): 조건이 만족되는 자료를 지운다. 진짜로 없애지는못해 사이즈는 고대로남는다.
	삭제(erase): 완전히 지워버린다 . 사이즈도 줄어든다.
		    또한 벡터의 중간에서 요소를 삭제하려면 erase()를 사용한다.

	Pair 이름과 랭크가 한번에 쌍으로 움직임. 그래서 랭크만가지고 정렬하면 이름도딸려옴
	*/



iterator 는 어떤 컨테이너 안에들어있는요소라도 쉽게 접근하기 위하여 만들어진것.
vector<double> scores; //double형 벡터 선언
vector<double>::iterator it//반복자선언 
it으로 접근할수있다. 
for(it = scores.begin() ; it!= scores.end() ; it++)
{
	if(*it >highest)
	   highest = *it;
}

## 주의점 ## 
it != scores.end() //마치 포인터 NULL과같은 의미이므로 
//it<= scores.end() 같은 작성은 하지말자. 자료가 저장된 위치가아니라는것

데크 (deque): 벡터와 아주유사한 동적배열 전단과 후단에서 요소를 추가하고 삭제 허용하는점이 벡터와다름


리스트(list): 벡터와 차이점은 
1.벡터에서는 임의 접근이 가능하지만 리스트는 불가능 . binary_search()와 같은알고리즘은 적용불가능
  첫번쨰 요소부터 순차적으로 이동하여야한다 . 
2. 벡터에서는 중간 위치에 삽입이나 삭제를 하려면 뒤의 요소들을 이동하여야 하므로 시간이 오래걸린다 . 
  리스트에서는 앞노드의 링크만 조작하면되므로 효율적으로 삽입이나 삭제가능 
3.리스트에서는 각데이터마다 링크를 저장하여야 하므로  기억 공간은 더많이 차지한다 .  
  벡터는 데이터만 저장되므로 크기가 더작다. 


맵(map): 원하는 데이터를 빠르게 찾을수있는 자료구조 Map이나 Multimap 객체를 생성하기 위해서는
           두가지의 타입을 명시해야한다 .  키와 값을 위한타입이다 . 
	Map을 이용하여 영어사전을 제작해보자 . 
	 insert()함수를 사용할수있지만,   dic["house"] = "집"; []를 사용하여 추가도가능

헤더 작성해놨음.








호선이 책

인라인 함수 

인라인함수와 매크로함수의 차이 :
매크로함수는 선행처리기에 의한 문자열대치방시긍로 호출될 코드를 삽입하지만 
인라인 함수는 컴파일러에 의한 코드 대치방식으로 호출될 코드를 삽입한다.

템플릿 함수 

네임스페이스가 뭔지 

ifdef TEST_H
#define TEST_H
#endif
이문장이 헤더파일을 두번이상 포함할때 한번만 컴파일하고 나머지는 무시하게만듬 

링크드 리스트 다시 공부 142p
배열처럼 특정요소에 바로접근이 불가능 앞에서부터 차례대로 들어가야함.
갯수의 제한은없음


딥카피 257p 다시공부 

정적 멤버함수 
정적멤버함수는 객체없이 호출할수있는 멤버함수 . 
1. 객체를 생성하지 않고 클래스 이름만으로 호출할 수 있습니다.

2. 객체를 생성하지 않으므로, this 포인터를 가지지 않습니다.

3. 특정 객체와 결합하지 않으므로, 정적 멤버 변수밖에 사용할 수 없습니다.

300쪽 class enum 다시 

https://wikidocs.net/22080