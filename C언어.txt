*strstr 문자열검색 > 욕설 필터링으로 사용 
strcmp >  대소문자를 식별하여 두문자열이 같은지 비교하는 함수 
memcmp> 메모리 비교 
memcpy > 메모리 복사 
memset >메모리 초기화  388p

	//402
//char szBuffer[32] = { "I am a boy." };
//char *length = strstr(szBuffer, "boy");
//
//printf("%p\n", szBuffer);
//printf("%p\n", strstr(szBuffer, "am"));
//printf("%p\n", strstr(szBuffer, "boy"));
//
//printf("Index: %d\n", strstr(szBuffer, "am" )- szBuffer);
//printf("Index: %d\n", strstr(szBuffer, "boy" )- szBuffer);
//memcpy(length, "cat", 3);
//
//printf("%s \n", szBuffer);


주소 -주소는 인덱스를 계산할수있다 . 

malloc  > 동적할당 메모리변수 
realloc  >
calloc   > malloc > memset 슨거랑 같은형태 초기화가 되서나옵니다 . 굿굿
free > 동적할당 메모리변수를 사용시 사용해줘야한다 아니면 메모리가 프로그램을 끄기전까지 남아있는다 .

sprintf > 메모리주소에 형식에맞추어 넣어주어야할때 사용한다 내가볼떈 scanf 랑 비슷한거같다 
sprintf_s>
_msize(szBuffer) >메모리크기 알려줌 


ceil(111.44);
floor(111.44);
abs(-14);
pow(2, 3);
sqrt(4);
exp(2);
log(10);
log10(10);
sin(),cos(),tan(),asin(),atan()



-----------------550페이지 파일 오픈 형태
system("notepad.exe test.txt"); //메모장으로 test파일열어라 . 


fopen = 파일여는거 
fclose = 파일열면 꼭닫는거
_fcloseall = 프로그램에서 열어둔 모든파일닫기 반환값으로 닫은파일갯수나옴 

fprintf = 문자열을 코드창에서 치면 그쪽으로들어감 "w"형태  (556페이지)
fscanf = 메모장에 쓰여있는 문자열을 읽어옴 "r"형태

fgetc
fputc = 한글자씩 읽어옴 (558p)

fputs =문자열을 코드창에서 입력 "w"형태 !!!! >> fprintf()랑차이점은 fprintf()는 형식을 지정 fputs는 문자열만 가능
fgets =\n까지 읽어옴 (559페이지) 이건 책을봐야암 한줄씩 끊어서 읽어온다 .

fflush = 


fseek = 파일 포인터를 이동시켜준다 . 
ftell = fseek(fp, 0, SEEK_END); 파일의 크기를 알려줌


fwrite(바이너리) = 바이어리파일에 정보를 쓰는함수 (566페이지 ) 코드창을 이용해서 파일에 값을 쓴다 . (구조체로 작성)
fread(바이너리)  = 바이너리파일에 정보를 읽어들이는 함수  (구조체로 불러들임 567페이지)

fseek 다시공부 
rewind :파일포인터를 처음으로 이동시켜준다 .
fflush 다시공부 


fread(저장장소 , 얼마만큼 (대부분 저장장소 크기만큼한다) , 갯수 , 무엇을);
fwrite(무엇을 , 크기 , 갯수 , 쓸장소 );


swap :메모리주소값들 서로 변경
atoi : 499P 문자형 "123"  = > 정수형 123으로 변환 
exit :응용프로그램 종료 

_access()함수 : 파일이 존재하는지 안하는지 판단해주는 함수 파일이존재하면 0 아니면 -1로 반환한다.


구조체배열 글자받아오기 528P

글자비교 문자처리 481p

extern 외부변수선언 


# 이랑 ## 출력시키는 용도로 사용하자 , 함수를 불러오는데 사용 
정수 +문자열 














1. putchar, fputc, getchar, fgetc

 위 함수들 모두 문자열이 아닌 '문자'를 입력하고 출력하는 함수들이다. putchar와 fputc는 출력 스트림을 표준 출력으로 할 지, 아니면 사용자가 지정할 것인지의 차이를 보인다. 이 점과 마찬가지로 getchar와 fgetc의 차이 역시, 입력 스트림을 표준 입력으로 할 지, 사용자가 지정할 것인지의 차이가 있다. 특이점은 리턴 타입이 int이므로 이점을 기억하여 사용해야 한다. 그리고 getchar의 경우 버퍼에 남아있는 개행 문자를 처리할 때도 사용한다는 점을 기억하자. 
 해당 함수를 이용할 때 알아두어야 할 내용 중에 하나는 EOF에 관한 것이다. End of File의 약자로, 파일의 끝까지 와서 더이상 읽어들일 내용이 없다는 뜻이다. 키보드 입력의 경우 Ctrl+D, Ctrl+Z 입력이 EOF를 의미하게 된다. 실제로 위 두 함수에서 반환하는 EOF는 -1로 정의된 상수임을 잊지 말자.

2. puts, fputs, gets, fgets

 위 함수 중 문자열 입력 함수인 gets, fgets가 scanf 함수와 보이는 가장 큰 차이점은 공백이 있는 문자열을 입력받을 수 있다는 점이다. 더불어, puts, fputs의 차이 및 gets, fgets의 차이점은 위에서 언급한 입/출력 스트림을 지정할 것인가, 아니면 표준 입/출력 스트림을 사용할 것인가의 차이다. 추가적으로 puts 함수는 자동으로 개행을 진행하지만, fputs 함수는 자동 개행을 하지 않는다. gets 함수를 사용함에 있어서 미리 마련된 배열의 길이를 넘어서는 문자열이 입력되면, 할당되지 않은 메모리 영역을 침범할 수 있는 우려가 있다. 따라서 가급적이면 fgets 함수를 사용하는 것이 유익하다. 그러나 fgets 함수에도 주의해야 할 점이 있다. fgets 함수를 사용하면 특정 사이즈만큼 입력받을 수 있는데, 문제는 맨 마지막에 Null 문자를 포함하기 때문에 지정한 크기보다 하나 작은 길이만큼 읽어들인다. 또, fgets 함수는 개행 문자를 만날 때까지 문자열을 읽어들이는데, 개행문자까지 문자열에 포함시킨다.





3. fflush

 출력 버퍼를 비우는 함수. 출력 버퍼를 비운다는 것은 출력 버퍼에 저장된 데이터가 목적지로 전달되는 것을 의미한다. 그러나 입력 버퍼를 비운다는 것은 전혀 다른 내용이다. 입력 버퍼의 비움은 곧 데이터의 소멸을 의미한다. 특히 입/출력 동작중에 유독 엔터-키로 인해서 개행문자가 삽입되는 바람에 출력이 원하는 형태로 되지 않는 경우가 있는데, 위에 1번에서 언급했던 것과 같이 getchar 함수를 활용하면 이런 문제를 해결할 수 있다. 아래의 함수를 참조하자.



void EmptyOutputBuffer(void) {

while(getchar != '\n');

}





4. strlen

 문자열의 길이를 출력해주는 함수다. 반환형이 unsigned int를 대변하는 size_t 타입이라서 출력할 때 경고 메시지가 뜨는 경우가 다분하다. %d가 아닌, %zu 형식을 사용하면 해결된다. 뒤에 따라오는 개행문자를 제거하고, 순수하게 유효한 문자열만 입력받는데 사용되기도 한다. 아래의 함수를 참조하자.  strlen 함수를 이용하여, 문자열의 길이를 파악한 후 맨 마지막 문자열을 개행문자에서 Null로써 대체하고 있다.



void PureString(char str[]) {

int len = strlen(str);

str[len-1] = 0;

}





5. strcpy, strncpy

 문자열 복사에 사용되는 함수다. strncpy는 특정 길이를 명세하여, 명세된 길이까지 복사한다. 그러나 이 함수를 사용하기 위해서는 주의해야할 점이 있다. strncpy 함수는 딱 정해진 크기만큼 복사하는데, 그 안에 Null 문자를 포함하지 않을 수 있다. 따라서 출력 해보면 이상한 메모리 위치에 접근하여, 원하는 출력이 안될 수 있다. 따라서 해당 함수를 사용할 때는 아래 코드처럼 우회해서 사용하는 편이 안전하다. 아래처럼 문자열의 마지막 위치에 강제적으로 Null을 삽입될 수 있도록, 하나 작은 값까지 복사를 진행하자.



strncpy(str2, str1, sizeof(str2)-1);

str2[sizeof(str2)-1] = 0;





6. strcat, strncat

 문자열을 이어붙여주는 함수다. 기억할만한 점은 앞 문자열의 Null 문자 위치부터 덧붙여진다는 점이다. 따라서 사용자는 한 문자열에 두 개의 Null 문자가 생길 수 있는 가능성을 무시하고 사용할 수 있다. strncat의 경우, 덧붙일 문자열의 크기를 지정할 수 있는데, 해당 크기에는 Null 문자가 포함되어 있지 않다. 만약 10을 인수로 전달했다면, 10개의 문자열과 Null 문자열이 덧붙여져서 총 11개의 문자가 추가된다.





7. strcmp, strncmp

 두 문자열이 동일한 지, 아닌지를 판별할 때 사용한다. 같으면 0을 반환하고, 0이 아니면 다른 문자열이라고만 기억해도 충분할 것 같다. strncmp를 사용할 일은 거의 없을 것 같다. 





8. atoi, atof, atol

 문자열을 int, double, long으로 변환해주는 함수. 앞서 소개한 함수들은 <string.h>에 선언된 함수지만, 이 함수들은 <stdlib.h>에 선언되어 있다.



