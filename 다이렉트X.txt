EPSILON = 0.001f;
fabs(lhs- rhs) < EPILON ? true; false;


벡터 크기와 방향
단위벡터 방향나타냄

(1,2,3) 벡터의 크기를 구하는건   
루트 1^2 + 2^2 + 3^2

벡터의 정규화 단위벡터가되게 만드는것 

(1,2,3) 단위벡터는 벡터의 크기만큼 나눠주면된다 .

스칼라곱 다시공부하기 -> 걍곱임 

내적 구하기 
1. 각각 선분들끼리 곱한다음에 더해주면됨 . 
2. 각각 벡터크기 구하고 곱해줌 또 그cos각 만큼 곱해줌

법선벡터 : 면에 수직인 벡터 
m_vEye 
내적해서 0   이면 직각 
내적 > 0     90보다 작다
내적 < 0     90보다 크다 


행렬
상등, 스칼라 곱, 더하기 

항등행렬
역행렬 = Confactor(행렬식 )
행렬의 전치 Transpose 전치행렬
minor 행렬 
Determinant 
Confactor 을 전치행렬해주면 Adjoint가 나온다 . 
역행렬 = (1/Determinant) * Adjoint 

이동 회전 다 행렬로 표현할거다 . 

회전할때 용어
롤 z 
요 y
피치 x

이동(역)행렬 55p
회전행렬 57p x y z
크기변형행렬 58p

SRT = world  
스케일 =1 // 2나 3이되면 확대가되는거고 
로테이션 = 1 //1 회전함수
트랜스레이트
 W 
뷰 
프로젝션 투영단계
뷰포트 
S-R-T-W-V-P-(VP)

//시야벡터와 각각의 폴리곤에대한 법선벡터가 있단말이야
		//어떤관계를 찾으면될까 
내적을하면되잖아
dot하면 어떻게된다고 

언제까지는 +값 
어디서부터 어디까지는 -값 
그걸이용해서 
아 이건 내눈에 안보이는거구나 .그거를 만들어봐

백페이스 컬링

//다이렉트X 설정
View - >otherManager - > Property Manager - > Microsoft.cpp.win32.user 더블클릭 
UserMacros 
$(VC_IncludePath);$(WindowsSDK_IncludePath);$(DH);
DL도해주고 
프로젝트 프로포티 ->Configuration Properties - > Configuration - > Configuration Manager클릭 -> 64bit 제거 86만사용할거
sln 프로포티 -> C++ ->General - > SDL checks = No,  Multi-process = YES ->Conde Generation->
Minimal Rebuild= no 끝



//장치관련을 cMainGame이아닌 장치관리 클래스를만들자 . CDeviceManager


float rotY = playerBody[0]->m_fRotY;
	D3DXMATRIXA16 rotYMat;
	D3DXMatrixRotationY(&rotYMat, rotY);
	
	for each(auto p in playerBody)
	{
		D3DXVECTOR3 newPos = p->GetPosition();
		D3DXVec3TransformNormal(&newPos, &newPos, &rotYMat);
		p->setPosition(newPos);
	}

공전 위에 


m_Tmat =playerBody[0]->GetTmat();

	for each(auto p in playerBody)
	{

		p->setTmat(m_Tmat);
		p->Update();
	}

자전 위에


